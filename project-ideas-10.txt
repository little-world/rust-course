 use only TODOs with
   pseudocode and hints, removing all complete implementations.
 
 3 Project Ideas for Chapter 4: Generics & Polymorphism

  Project 1: Generic Data Structure Library with Const Generics

  Focus: Generic containers, const generics, trait bounds, zero-cost
  abstractions

  Build a collection of generic data structures that leverage const generics
   for compile-time size guarantees. Students implement:
  - Generic fixed-size stack Stack<T, const N: usize> with array backing
  - Generic ring buffer RingBuffer<T, const N: usize> for circular queuing
  - Generic binary heap BinaryHeap<T: Ord, const N: usize> with bounds
  checking
  - Generic trait Container<T> with associated types for iterators
  - Comparison function abstraction with Fn trait bounds
  - Custom derive-like functionality using generic builder patterns

  Why it matters: Demonstrates monomorphization benefits, const generics for
   array sizes, trait bounds for operations (Ord, Clone, Default), and
  zero-cost abstractions. Shows how generics enable writing reusable
  containers that compile to optimal machine code for each type.

  ---
  Project 2: Generic Expression Evaluator with Type-Level State

  Focus: Phantom types, type-state pattern, associated types, trait objects
  vs generics

  Build an expression evaluator that uses the type system to enforce
  correctness at compile time. Students implement:
  - Generic Expr<T> for expressions over different numeric types (i32, f64,
  etc.)
  - Type-state pattern for validated vs unvalidated expressions using
  phantom types
  - Associated type traits for operator overloading (Add, Mul, etc.)
  - Generic visitor pattern for tree traversal with trait bounds
  - Comparison between static dispatch (generics) and dynamic dispatch
  (trait objects)
  - Generic parser using higher-ranked trait bounds for lifetime flexibility

  Why it matters: Shows advanced generic patterns like phantom types for
  compile-time guarantees, type-state pattern for API safety, and when to
  choose generics vs trait objects (static vs dynamic dispatch trade-offs).

  ---
  Project 3: Type-Safe Query Builder with Associated Types

  Focus: Associated types, method chaining, builder pattern, zero-sized
  types (ZSTs)

  Build a compile-time SQL-like query builder that prevents invalid queries
  through the type system. Students implement:
  - Generic Query<T, S> where T is entity type and S is state (phantom type)
  - Associated types for query results (type Output)
  - Type-state pattern: Unfiltered → Filtered → Sorted → Ready
  - Generic trait bounds for filterable/sortable types
  - Zero-sized types for state transitions (no runtime cost)
  - Generic Select<T>, Where<T, P>, OrderBy<T, F> builders with method
  chaining
  - Compile errors for invalid query construction (e.g., sorting before
  filtering)

  Why it matters: Demonstrates how generics + associated types create
  ergonomic, type-safe APIs. Shows zero-cost abstractions (ZSTs compile to
  nothing), builder pattern with type states, and leveraging the compiler
  for correctness guarantees that would be runtime errors in other
  languages.

  ---
  Common Themes Across Projects:
  - Monomorphization and zero-cost abstractions
  - Trait bounds for constraining generic types
  - Const generics for compile-time values
  - Associated types vs generic type parameters
  - Type-state pattern with phantom types
  - Static dispatch (generics) vs dynamic dispatch (trait objects)
  - Ergonomic API design with generics

  These projects teach progressively advanced generic concepts while
  building practical tools (data structures, expression evaluator, query
  builder) that demonstrate Rust's type system strengths.
  
  
  
  
  
  3 Project Ideas for Chapter 6: Lifetime Patterns

   Based on the chapter content covering lifetime elision, bounds,
   higher-ranked trait bounds, variance, and Pin, here are 3 unique project 
   ideas:

   ---
   Project 1: Zero-Copy Text Parser with Lifetime-Aware Tokens

   Focus: Lifetime elision, lifetime bounds, struct lifetimes, zero-copy
   parsing

   Build a text parser that borrows from the input without allocating, using
   lifetimes to ensure tokens remain valid. Students implement:
   - Parser<'input> struct holding a reference to input text
   - Token<'a> enum with borrowed string slices (no String allocation)
   - Lifetime-aware tokenizer that yields &'input str tokens
   - Multiple lifetime parameters for parser context vs input
   - peek() and advance() methods with proper lifetime annotations
   - Iterator implementation returning borrowed tokens
   - Compile-time guarantee that tokens can't outlive input

   Why it matters: Demonstrates zero-copy parsing (common in compilers, JSON
   parsers), lifetime elision rules in practice, how lifetimes prevent
   use-after-free in parsers, and performance benefits of borrowing vs
   allocating (10-100x faster for large inputs). Shows struct lifetimes,
   method lifetime elision, and returning references from multiple sources.

   ---
   Project 2: Streaming Iterator with Higher-Ranked Trait Bounds (HRTB)

   Focus: Higher-ranked trait bounds, GATs (Generic Associated Types),
   streaming iteration, lifetime variance

   Build a streaming iterator that yields borrowed elements with complex
   lifetime requirements. Students implement:
   - StreamingIterator trait with for<'a> HRTB for flexible lifetimes
   - Item<'a> associated type that depends on loan lifetime
   - Window iterator over slices: Windows<'data, T> yielding &'window [T]
   - Group-by iterator that borrows consecutive equal elements
   - Lifetime variance: covariant, contravariant, invariant positions
   - Comparison with standard Iterator (owned items vs borrowed)
   - next() method with for<'a> fn(&'a mut self) -> Option<Item<'a>>

   Why it matters: Demonstrates advanced lifetime patterns not possible with
   standard iterators, HRTB for "works with any lifetime", GATs for
   lifetime-parameterized associated types, and zero-copy iteration over
   streaming data (log files, network packets). Shows when standard Iterator
   is insufficient and why streaming iterators require HRTB.

   ---
   Project 3: Self-Referential Future with Pin and Lifetime Management

   Focus: Pin, self-referential structs, async/await lifetimes, variance,
   unsafe lifetime extension

   Build a self-referential async structure using Pin to enable safe
   self-references. Students implement:
   - SelfRefFuture<'a> that holds data and borrows from itself
   - Pin-based API preventing moves that would invalidate pointers
   - project() method for safe field access on pinned data
   - Lifetime relationships between pinned data and projections
   - Async fn returning references with proper lifetime bounds
   - Comparison: stack pinning vs heap pinning (Box::pin)
   - Unsafe code with lifetime soundness proofs

   Why it matters: Demonstrates why self-referential structs need Pin
   (prevent moving), how async/await creates self-references (futures holding
    references to their own fields), practical use of Pin<&mut T> and Unpin,
   and safe abstractions over unsafe lifetime manipulation. Essential for
   async Rust and zero-copy futures.

   ---
   Common Themes Across Projects:

   - Lifetime elision rules and when explicit annotations are required
   - Struct lifetimes (Parser<'a>, Token<'a>)
   - Lifetime bounds (T: 'a, 'b: 'a)
   - Higher-ranked trait bounds (for<'a>)
   - Zero-copy patterns (borrowing instead of allocating)
   - Variance (covariant, contravariant, invariant lifetimes)
   - Pin for self-referential structs
   - Lifetime hierarchies and outlives relationships

   These projects progress from basic lifetime annotations (Project 1) to
   advanced patterns like HRTB (Project 2) and Pin (Project 3), teaching the
   full spectrum of Rust's lifetime system through practical applications
   like parsers, iterators, and async futures.
  
 Project Ideas for Chapter 7: Advanced Pattern Matching

  Project 1: Regular Expression Engine with Pattern Matching

  Focus: Exhaustive matching, guards, deep destructuring, slice patterns

  Build a regex engine that compiles patterns into an AST and evaluates them
   using Rust's pattern matching features. Demonstrates:
  - Exhaustive enum matching for all regex constructs (literals, wildcards,
  character classes, quantifiers, groups, alternation)
  - Pattern guards for validation and optimization
  - Range patterns for character classes ('a'..='z')
  - Slice patterns for sequence matching
  - Deep destructuring for nested expressions
  - matches! macro for quick checks
  - Let-else patterns for error handling

  Key Features: Literal matching, wildcards (.), character classes ([a-z]),
  quantifiers (*, +, ?, {n,m}), alternation (|), capture groups, anchors (^,
   $, \b), backtracking, optimization

  Project 2: Network Packet Inspector with Binary Pattern Matching

  Focus: Binary data patterns, nested protocol destructuring, firewall rules

  Build a network packet analyzer that parses binary protocols (Ethernet,
  IP, TCP, UDP, HTTP) and implements a firewall rule engine. Demonstrates:
  - Byte slice pattern matching for parsing headers
  - Deep destructuring through protocol layers (Ethernet → IP → TCP → HTTP)
  - Range patterns for port filtering (1..=1023 for well-known ports)
  - Pattern guards for complex firewall rules
  - Or-patterns for service detection (port 80 | 8080 | 8000)
  - If-let chains for payload validation
  - Exhaustive protocol matching
  - Connection state tracking with pattern matching

  Key Features: Multi-layer packet parsing, firewall rule engine, deep
  packet inspection, HTTP threat detection (SQL injection, XSS), connection
  tracking, TCP state machine, statistics

  Project 3: Business Rule Engine with Enum-Driven Architecture

  Focus: Rule composition, temporal logic, exhaustive business logic

  Build a business rule engine for e-commerce/finance that encodes business
  logic as enums and evaluates them with pattern matching. Demonstrates:
  - Exhaustive matching for all rule types (equality, comparisons, ranges,
  string matching, temporal)
  - Rule composition with nested enums (AND, OR, NOT)
  - Pattern guards for complex conditions
  - Range patterns for numeric/date ranges
  - Tuple matching for multi-field conditions
  - Priority-based rule evaluation
  - If-let chains for rule validation
  - Matches! macro for quick rule checks

  Key Features: Discount/promotion rules, credit approval logic, fraud
  scoring, temporal rules (time ranges, day of week), rule priorities,
  conflict resolution, rule chaining, dynamic rule loading, validation
  
  
  Project 4: JSON Parser with Pattern-Based Validation

   Focus: Nested destructuring, recursive patterns, or-patterns, pattern
   guards for validation

   Build a JSON parser and validator that uses pattern matching to parse JSON
    strings into an AST and validate against schemas. This project
   demonstrates:
   - Exhaustive enum matching for all JSON types (object, array, string,
   number, boolean, null)
   - Deep destructuring for nested JSON structures
   - Recursive pattern matching for traversing complex documents
   - Pattern guards for schema validation rules
   - Or-patterns for type unions in schemas
   - Slice patterns for array validation
   - If-let chains for optional field handling
   - Let-else patterns for required field extraction

   Key Features: Tokenization, recursive descent parsing, schema definition
   language, type checking, required/optional fields, min/max constraints,
   pattern validation (regex for strings), array length validation, nested
   object validation, custom validators, error reporting with paths

   Real-World Application: This pattern is used in API validation,
   configuration file parsing, data serialization/deserialization, and
   type-safe data transformation.

   ---
   Project 5: State Machine for Protocol Implementation

   Focus: Exhaustive state transitions, nested event matching, pattern guards
    for preconditions

   Build a type-safe state machine framework and implement a complete TCP
   connection state machine. This project demonstrates:
   - Exhaustive enum matching for all states and events
   - Pattern matching on (State, Event) tuples for transitions
   - Pattern guards for transition preconditions and validation
   - Or-patterns for grouping similar transitions
   - Nested enum matching for event data extraction
   - matches! macro for quick state checks
   - Compile-time guarantees that all state/event combinations are handled
   - Invalid state transition detection at compile time

   Key Features: State enum with associated data, Event enum for inputs,
   transition function with exhaustive (state, event) matching, entry/exit
   actions, transition guards, state history tracking, timeout events, error
   states, state machine visualization, comprehensive transition coverage

   Real-World Application: This pattern is used in network protocol
   implementations (TCP, HTTP/2), parser state machines, game AI, workflow
   engines, and embedded system controllers.

   ---
   Project 6: AST-Based Configuration Language Interpreter

   Focus: Deep destructuring, recursive evaluation, pattern guards for type
   checking

   Build an interpreter for a configuration language (similar to
   HCL/Terraform) that uses pattern matching to evaluate expressions, resolve
    variables, and apply transformations. This project demonstrates:
   - Exhaustive enum matching for AST nodes (literals, variables, blocks,
   attributes, functions)
   - Deep destructuring for nested configuration blocks
   - Recursive pattern matching for expression evaluation
   - Pattern guards for type checking and validation
   - Or-patterns for accepting multiple compatible types
   - Slice patterns for function argument matching
   - Let-else patterns for error handling during evaluation
   - matches! macro for AST node type checking

   Key Features: Lexer/parser for configuration syntax, AST representation,
   variable scoping and resolution, built-in functions (merge, concat, map,
   filter), type system (string, number, bool, list, map), interpolation
   syntax "${var.name}", block inheritance and overrides, conditional
   expressions, for-each loops, module system, validation and error reporting

   Real-World Application: This pattern is used in infrastructure-as-code
   tools (Terraform, Pulumi), build systems (Bazel, Buck), application config
    (Kubernetes manifests), and DSL interpreters.

   ---
  
