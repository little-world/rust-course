//! Pattern 2: Diesel Full-Featured ORM
//!
//! Demonstrates Diesel's type-safe query DSL that compiles to SQL.
//! The table! macro creates type-safe column references.

use chrono::NaiveDateTime;
use diesel::prelude::*;

// Define schema (typically generated by `diesel print-schema`)
diesel::table! {
    users (id) {
        id -> Int4,
        username -> Varchar,
        email -> Varchar,
        created_at -> Timestamp,
    }
}

// Define model for reading
#[derive(Queryable, Selectable, Debug)]
#[diesel(table_name = users)]
struct User {
    id: i32,
    username: String,
    email: String,
    created_at: NaiveDateTime,
}

// Define model for inserting (different derive!)
#[derive(Insertable)]
#[diesel(table_name = users)]
struct NewUser<'a> {
    username: &'a str,
    email: &'a str,
}

/// Connect to database
fn establish_connection(database_url: &str) -> ConnectionResult<PgConnection> {
    PgConnection::establish(database_url)
}

/// Fetch user with Diesel's query DSL
fn fetch_user_diesel(conn: &mut PgConnection, user_id: i32) -> QueryResult<User> {
    use self::users::dsl::*;

    // This compiles to: SELECT * FROM users WHERE id = $1
    users.find(user_id).select(User::as_select()).first(conn)
}

/// Create user
fn create_user_diesel(
    conn: &mut PgConnection,
    new_username: &str,
    new_email: &str,
) -> QueryResult<User> {
    use self::users::dsl::*;

    let new_user = NewUser {
        username: new_username,
        email: new_email,
    };

    diesel::insert_into(users)
        .values(&new_user)
        .returning(User::as_returning())
        .get_result(conn)
}

/// Complex query with filter and ordering
fn find_active_users(conn: &mut PgConnection, days: i64) -> QueryResult<Vec<User>> {
    use self::users::dsl::*;

    let cutoff = chrono::Utc::now().naive_utc() - chrono::Duration::days(days);

    // This compiles to:
    // SELECT * FROM users
    // WHERE created_at > $1
    // ORDER BY username ASC
    // LIMIT 100
    users
        .filter(created_at.gt(cutoff))
        .order(username.asc())
        .limit(100)
        .select(User::as_select())
        .load(conn)
}

/// Update user email
fn update_user_email(
    conn: &mut PgConnection,
    user_id: i32,
    new_email: &str,
) -> QueryResult<User> {
    use self::users::dsl::*;

    diesel::update(users.find(user_id))
        .set(email.eq(new_email))
        .returning(User::as_returning())
        .get_result(conn)
}

/// Delete user
fn delete_user(conn: &mut PgConnection, user_id: i32) -> QueryResult<usize> {
    use self::users::dsl::*;

    diesel::delete(users.find(user_id)).execute(conn)
}

fn demonstrate_diesel_dsl() {
    println!("=== Diesel Query DSL ===\n");

    println!("--- How Diesel Works ---\n");
    println!("1. table! macro creates type-safe column references");
    println!("2. #[derive(Queryable)] maps rows to structs");
    println!("3. #[derive(Insertable)] enables INSERT from structs");
    println!("4. Queries read like Rust, compile to SQL\n");

    println!("--- Query Examples ---\n");

    println!("users.find(id)");
    println!("  -> SELECT * FROM users WHERE id = $1\n");

    println!("users.filter(created_at.gt(date)).order(username.asc())");
    println!("  -> SELECT * FROM users WHERE created_at > $1 ORDER BY username ASC\n");

    println!("diesel::insert_into(users).values(&new_user)");
    println!("  -> INSERT INTO users (username, email) VALUES ($1, $2)\n");

    println!("diesel::update(users.find(id)).set(email.eq(new_email))");
    println!("  -> UPDATE users SET email = $1 WHERE id = $2\n");

    println!("--- Type Safety ---\n");
    println!("filter(id.eq(\"not_a_number\"))  // WON'T COMPILE!");
    println!("filter(nonexistent_column.eq(1)) // WON'T COMPILE!");
    println!("The compiler catches type mismatches.\n");

    println!("--- Trade-offs ---\n");
    println!("Pros:");
    println!("  + Full type safety at compile time");
    println!("  + Refactoring updates in one place");
    println!("  + No raw SQL strings to maintain\n");
    println!("Cons:");
    println!("  - Steeper learning curve");
    println!("  - Can't express all SQL (CTEs, window functions)");
    println!("  - Schema codegen step required\n");
}

fn main() {
    println!("=== Pattern 2: Diesel Full-Featured ORM ===\n");

    demonstrate_diesel_dsl();

    // Try to connect
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgresql://user:pass@localhost/mydb".to_string());

    println!("--- Connection Test ---\n");

    match establish_connection(&database_url) {
        Ok(mut conn) => {
            println!("Connected successfully!\n");

            match fetch_user_diesel(&mut conn, 1) {
                Ok(user) => println!("Fetched: {:?}", user),
                Err(e) => println!("Query error: {}", e),
            }
        }
        Err(e) => {
            println!("Connection failed: {}", e);
            println!("(Expected without running database)");
        }
    }

    println!("\nDiesel ORM example completed!");
}
