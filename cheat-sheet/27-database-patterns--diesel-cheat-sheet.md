### Diesel Cheat Sheet
```rust
// Cargo.toml:
/*
[dependencies]
diesel = { version = "2.1", features = ["postgres", "mysql", "sqlite", "r2d2", "chrono", "uuid"] }
diesel_migrations = "2.1"
dotenvy = "0.15"
chrono = "0.4"
uuid = { version = "1.0", features = ["v4"] }
*/

// ===== SETUP AND SCHEMA =====
// schema.rs (generated by diesel CLI)
// Run: diesel setup
// Run: diesel migration generate create_users

diesel::table! {
    users (id) {
        id -> Int4,
        username -> Varchar,
        email -> Varchar,
        created_at -> Timestamp,
    }
}

diesel::table! {
    posts (id) {
        id -> Int4,
        title -> Varchar,
        body -> Text,
        published -> Bool,
        user_id -> Int4,
        created_at -> Timestamp,
    }
}

diesel::table! {
    comments (id) {
        id -> Int4,
        content -> Text,
        post_id -> Int4,
        user_id -> Int4,
        created_at -> Timestamp,
    }
}

diesel::joinable!(posts -> users (user_id));
diesel::joinable!(comments -> posts (post_id));
diesel::joinable!(comments -> users (user_id));

diesel::allow_tables_to_appear_in_same_query!(users, posts, comments,);

// ===== DATABASE CONNECTION =====
use diesel::prelude::*;
use diesel::pg::PgConnection;
use diesel::mysql::MysqlConnection;
use diesel::sqlite::SqliteConnection;
use std::env;

// PostgreSQL connection
fn establish_pg_connection() -> PgConnection {
    let database_url = env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");
    
    PgConnection::establish(&database_url)
        .unwrap_or_else(|_| panic!("Error connecting to {}", database_url))
}

// SQLite connection
fn establish_sqlite_connection() -> SqliteConnection {
    let database_url = "test.db";
    SqliteConnection::establish(database_url)
        .unwrap_or_else(|_| panic!("Error connecting to {}", database_url))
}

// ===== CONNECTION POOL =====
use diesel::r2d2::{self, ConnectionManager, Pool, PooledConnection};

type PgPool = Pool<ConnectionManager<PgConnection>>;
type PgPooledConnection = PooledConnection<ConnectionManager<PgConnection>>;

fn create_pool() -> PgPool {
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    
    Pool::builder()
        .max_size(15)                                        // Max connections
        .min_idle(Some(5))                                   // Min idle connections
        .connection_timeout(std::time::Duration::from_secs(30))
        .build(manager)
        .expect("Failed to create pool")
}

fn get_connection(pool: &PgPool) -> PgPooledConnection {
    pool.get().expect("Failed to get connection from pool")
}

// ===== MODELS =====
use chrono::NaiveDateTime;
use serde::{Deserialize, Serialize};

// Queryable model (for reading from database)
#[derive(Debug, Queryable, Selectable, Serialize)]
#[diesel(table_name = users)]
pub struct User {
    pub id: i32,
    pub username: String,
    pub email: String,
    pub created_at: NaiveDateTime,
}

// Insertable model (for inserting into database)
#[derive(Debug, Insertable)]
#[diesel(table_name = users)]
pub struct NewUser<'a> {
    pub username: &'a str,
    pub email: &'a str,
}

// Changeset model (for updates)
#[derive(Debug, AsChangeset)]
#[diesel(table_name = users)]
pub struct UpdateUser<'a> {
    pub username: Option<&'a str>,
    pub email: Option<&'a str>,
}

// Post models
#[derive(Debug, Queryable, Selectable, Serialize, Associations)]
#[diesel(belongs_to(User))]
#[diesel(table_name = posts)]
pub struct Post {
    pub id: i32,
    pub title: String,
    pub body: String,
    pub published: bool,
    pub user_id: i32,
    pub created_at: NaiveDateTime,
}

#[derive(Debug, Insertable)]
#[diesel(table_name = posts)]
pub struct NewPost<'a> {
    pub title: &'a str,
    pub body: &'a str,
    pub user_id: i32,
}

// ===== CREATE (INSERT) =====
use self::users::dsl::*;

// Insert single record
fn create_user(conn: &mut PgConnection, username_str: &str, email_str: &str) -> User {
    let new_user = NewUser {
        username: username_str,
        email: email_str,
    };
    
    diesel::insert_into(users)
        .values(&new_user)
        .returning(User::as_returning())
        .get_result(conn)
        .expect("Error saving new user")
}

// Insert and get ID only
fn create_user_get_id(conn: &mut PgConnection, username_str: &str, email_str: &str) -> i32 {
    let new_user = NewUser {
        username: username_str,
        email: email_str,
    };
    
    diesel::insert_into(users)
        .values(&new_user)
        .returning(id)
        .get_result(conn)
        .expect("Error saving new user")
}

// Insert multiple records
fn create_users_bulk(conn: &mut PgConnection, new_users: &[NewUser]) -> Vec<User> {
    diesel::insert_into(users)
        .values(new_users)
        .returning(User::as_returning())
        .get_results(conn)
        .expect("Error saving users")
}

// Insert or ignore (on conflict do nothing)
fn insert_or_ignore(conn: &mut PgConnection, new_user: &NewUser) -> QueryResult<usize> {
    diesel::insert_into(users)
        .values(new_user)
        .on_conflict_do_nothing()
        .execute(conn)
}

// Insert or update (upsert)
fn upsert_user(conn: &mut PgConnection, new_user: &NewUser) -> User {
    diesel::insert_into(users)
        .values(new_user)
        .on_conflict(email)
        .do_update()
        .set((username.eq(new_user.username),))
        .returning(User::as_returning())
        .get_result(conn)
        .expect("Error upserting user")
}

// ===== READ (SELECT) =====
// Get all records
fn get_all_users(conn: &mut PgConnection) -> Vec<User> {
    users
        .select(User::as_select())
        .load(conn)
        .expect("Error loading users")
}

// Get single record by ID
fn get_user_by_id(conn: &mut PgConnection, user_id: i32) -> Option<User> {
    users
        .find(user_id)
        .select(User::as_select())
        .first(conn)
        .optional()
        .expect("Error loading user")
}

// Filter queries
fn find_users_by_username(conn: &mut PgConnection, username_str: &str) -> Vec<User> {
    users
        .filter(username.eq(username_str))
        .select(User::as_select())
        .load(conn)
        .expect("Error loading users")
}

// Multiple conditions
fn find_users_complex(conn: &mut PgConnection) -> Vec<User> {
    users
        .filter(username.like("%john%"))
        .filter(email.is_not_null())
        .order(created_at.desc())
        .limit(10)
        .offset(0)
        .select(User::as_select())
        .load(conn)
        .expect("Error loading users")
}

// Select specific columns
fn get_usernames(conn: &mut PgConnection) -> Vec<String> {
    users
        .select(username)
        .load(conn)
        .expect("Error loading usernames")
}

// Select multiple columns
fn get_user_info(conn: &mut PgConnection) -> Vec<(i32, String, String)> {
    users
        .select((id, username, email))
        .load(conn)
        .expect("Error loading user info")
}

// Count
fn count_users(conn: &mut PgConnection) -> i64 {
    users
        .count()
        .get_result(conn)
        .expect("Error counting users")
}

// First/Last
fn get_first_user(conn: &mut PgConnection) -> Option<User> {
    users
        .select(User::as_select())
        .first(conn)
        .optional()
        .expect("Error loading user")
}

// ===== UPDATE =====
// Update single record
fn update_user(conn: &mut PgConnection, user_id: i32, new_username: &str) -> User {
    diesel::update(users.find(user_id))
        .set(username.eq(new_username))
        .returning(User::as_returning())
        .get_result(conn)
        .expect("Error updating user")
}

// Update with changeset
fn update_user_changeset(
    conn: &mut PgConnection,
    user_id: i32,
    changeset: &UpdateUser,
) -> User {
    diesel::update(users.find(user_id))
        .set(changeset)
        .returning(User::as_returning())
        .get_result(conn)
        .expect("Error updating user")
}

// Update multiple records
fn update_all_users(conn: &mut PgConnection) -> usize {
    diesel::update(users)
        .set(username.eq("updated"))
        .execute(conn)
        .expect("Error updating users")
}

// Conditional update
fn update_inactive_users(conn: &mut PgConnection) -> usize {
    use chrono::{Duration, Utc};
    let cutoff = Utc::now().naive_utc() - Duration::days(30);
    
    diesel::update(users.filter(created_at.lt(cutoff)))
        .set(username.eq("inactive"))
        .execute(conn)
        .expect("Error updating users")
}

// ===== DELETE =====
// Delete single record
fn delete_user(conn: &mut PgConnection, user_id: i32) -> usize {
    diesel::delete(users.find(user_id))
        .execute(conn)
        .expect("Error deleting user")
}

// Delete with filter
fn delete_users_by_username(conn: &mut PgConnection, username_str: &str) -> usize {
    diesel::delete(users.filter(username.eq(username_str)))
        .execute(conn)
        .expect("Error deleting users")
}

// Delete all
fn delete_all_users(conn: &mut PgConnection) -> usize {
    diesel::delete(users)
        .execute(conn)
        .expect("Error deleting users")
}

// ===== JOINS =====
use self::posts::dsl::*;

// Inner join
fn get_users_with_posts(conn: &mut PgConnection) -> Vec<(User, Post)> {
    users
        .inner_join(posts)
        .select((User::as_select(), Post::as_select()))
        .load(conn)
        .expect("Error loading users with posts")
}

// Left join
fn get_all_users_and_their_posts(conn: &mut PgConnection) -> Vec<(User, Option<Post>)> {
    users
        .left_join(posts)
        .select((User::as_select(), Option::<Post>::as_select()))
        .load(conn)
        .expect("Error loading users and posts")
}

// Get posts for specific user
fn get_user_posts(conn: &mut PgConnection, user_id: i32) -> Vec<Post> {
    Post::belonging_to(&users.find(user_id).first::<User>(conn).unwrap())
        .select(Post::as_select())
        .load(conn)
        .expect("Error loading posts")
}

// ===== ASSOCIATIONS =====
// One-to-many: Get posts grouped by user
fn get_posts_grouped_by_user(conn: &mut PgConnection) -> Vec<(User, Vec<Post>)> {
    let all_users = users
        .select(User::as_select())
        .load(conn)
        .expect("Error loading users");
    
    let all_posts = Post::belonging_to(&all_users)
        .select(Post::as_select())
        .load(conn)
        .expect("Error loading posts");
    
    let grouped = all_posts.grouped_by(&all_users);
    
    all_users.into_iter().zip(grouped).collect()
}

// ===== TRANSACTIONS =====
fn transaction_example(conn: &mut PgConnection) -> QueryResult<()> {
    conn.transaction(|conn| {
        let user = create_user(conn, "john", "john@example.com");
        
        let new_post = NewPost {
            title: "First Post",
            body: "Hello, World!",
            user_id: user.id,
        };
        
        diesel::insert_into(posts)
            .values(&new_post)
            .execute(conn)?;
        
        Ok(())
    })
}

// Nested transactions
fn nested_transaction(conn: &mut PgConnection) -> QueryResult<()> {
    conn.transaction(|conn| {
        // Outer transaction
        let user = create_user(conn, "alice", "alice@example.com");
        
        conn.transaction(|conn| {
            // Inner transaction
            let new_post = NewPost {
                title: "Post",
                body: "Content",
                user_id: user.id,
            };
            
            diesel::insert_into(posts)
                .values(&new_post)
                .execute(conn)
        })?;
        
        Ok(())
    })
}

// ===== RAW SQL =====
use diesel::sql_types::*;
use diesel::sql_query;

// Execute raw SQL
fn raw_sql_query(conn: &mut PgConnection) -> QueryResult<Vec<User>> {
    sql_query("SELECT * FROM users WHERE id > 10")
        .load::<User>(conn)
}

// Raw SQL with parameters
#[derive(QueryableByName, Debug)]
struct UserCount {
    #[diesel(sql_type = BigInt)]
    count: i64,
}

fn raw_sql_with_params(conn: &mut PgConnection, min_id: i32) -> QueryResult<i64> {
    let result: UserCount = sql_query("SELECT COUNT(*) as count FROM users WHERE id > $1")
        .bind::<Integer, _>(min_id)
        .get_result(conn)?;
    
    Ok(result.count)
}

// Execute statement (no results)
fn raw_sql_execute(conn: &mut PgConnection) -> QueryResult<usize> {
    sql_query("UPDATE users SET username = 'updated' WHERE id = 1")
        .execute(conn)
}

// ===== AGGREGATIONS =====
use diesel::dsl::*;

// Count
fn count_posts_by_user(conn: &mut PgConnection, user_id: i32) -> i64 {
    posts
        .filter(self::posts::user_id.eq(user_id))
        .count()
        .get_result(conn)
        .expect("Error counting posts")
}

// Group by and count
#[derive(QueryableByName, Debug)]
struct PostCount {
    #[diesel(sql_type = Integer)]
    user_id: i32,
    #[diesel(sql_type = BigInt)]
    count: i64,
}

fn posts_count_by_user(conn: &mut PgConnection) -> Vec<PostCount> {
    sql_query("SELECT user_id, COUNT(*) as count FROM posts GROUP BY user_id")
        .load(conn)
        .expect("Error loading post counts")
}

// ===== SUBQUERIES =====
fn users_with_posts(conn: &mut PgConnection) -> Vec<User> {
    let subquery = posts.select(self::posts::user_id);
    
    users
        .filter(id.eq_any(subquery))
        .select(User::as_select())
        .load(conn)
        .expect("Error loading users")
}

// ===== PAGINATION =====
fn paginate_users(
    conn: &mut PgConnection,
    page: i64,
    per_page: i64,
) -> Vec<User> {
    users
        .limit(per_page)
        .offset(page * per_page)
        .select(User::as_select())
        .load(conn)
        .expect("Error loading users")
}

// ===== ORDERING =====
fn get_users_ordered(conn: &mut PgConnection) -> Vec<User> {
    users
        .order(created_at.desc())                            // Descending
        .select(User::as_select())
        .load(conn)
        .expect("Error loading users")
}

fn get_users_multiple_order(conn: &mut PgConnection) -> Vec<User> {
    users
        .order((username.asc(), created_at.desc()))
        .select(User::as_select())
        .load(conn)
        .expect("Error loading users")
}

// ===== FILTERING =====
fn complex_filter(conn: &mut PgConnection) -> Vec<User> {
    users
        .filter(username.like("%john%"))                     // LIKE
        .filter(email.is_not_null())                         // IS NOT NULL
        .filter(id.gt(10))                                   // Greater than
        .filter(id.le(100))                                  // Less than or equal
        .filter(username.ne("admin"))                        // Not equal
        .select(User::as_select())
        .load(conn)
        .expect("Error loading users")
}

// OR conditions
fn filter_with_or(conn: &mut PgConnection) -> Vec<User> {
    users
        .filter(username.eq("john").or(username.eq("jane")))
        .select(User::as_select())
        .load(conn)
        .expect("Error loading users")
}

// IN clause
fn filter_in(conn: &mut PgConnection, ids: Vec<i32>) -> Vec<User> {
    users
        .filter(id.eq_any(ids))
        .select(User::as_select())
        .load(conn)
        .expect("Error loading users")
}

// BETWEEN
fn filter_between(conn: &mut PgConnection) -> Vec<User> {
    users
        .filter(id.between(10, 20))
        .select(User::as_select())
        .load(conn)
        .expect("Error loading users")
}

// ===== MIGRATIONS =====
// In migrations/TIMESTAMP_create_users/up.sql:
/*
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR NOT NULL,
    email VARCHAR NOT NULL UNIQUE,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);
*/

// In migrations/TIMESTAMP_create_users/down.sql:
/*
DROP TABLE users;
*/

// Run migrations programmatically
use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};

pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!("migrations");

fn run_migrations(conn: &mut PgConnection) {
    conn.run_pending_migrations(MIGRATIONS)
        .expect("Failed to run migrations");
}

// ===== COMMON PATTERNS =====

// Pattern 1: Find or create
fn find_or_create_user(
    conn: &mut PgConnection,
    email_str: &str,
) -> User {
    match users
        .filter(email.eq(email_str))
        .select(User::as_select())
        .first(conn)
        .optional()
        .expect("Error loading user")
    {
        Some(user) => user,
        None => {
            let new_user = NewUser {
                username: email_str.split('@').next().unwrap(),
                email: email_str,
            };
            
            diesel::insert_into(users)
                .values(&new_user)
                .returning(User::as_returning())
                .get_result(conn)
                .expect("Error creating user")
        }
    }
}

// Pattern 2: Batch insert
fn batch_insert(conn: &mut PgConnection, new_users: Vec<NewUser>) {
    for chunk in new_users.chunks(1000) {
        diesel::insert_into(users)
            .values(chunk)
            .execute(conn)
            .expect("Error inserting users");
    }
}

// Pattern 3: Soft delete
diesel::table! {
    soft_delete_users (id) {
        id -> Int4,
        username -> Varchar,
        deleted_at -> Nullable<Timestamp>,
    }
}

fn soft_delete(conn: &mut PgConnection, user_id: i32) {
    use self::soft_delete_users::dsl::*;
    use chrono::Utc;
    
    diesel::update(soft_delete_users.find(user_id))
        .set(deleted_at.eq(Some(Utc::now().naive_utc())))
        .execute(conn)
        .expect("Error soft deleting user");
}

fn get_active_users(conn: &mut PgConnection) -> Vec<i32> {
    use self::soft_delete_users::dsl::*;
    
    soft_delete_users
        .filter(deleted_at.is_null())
        .select(id)
        .load(conn)
        .expect("Error loading users")
}

// Pattern 4: Exists check
fn user_exists(conn: &mut PgConnection, email_str: &str) -> bool {
    use diesel::dsl::exists;
    use diesel::dsl::select;
    
    select(exists(users.filter(email.eq(email_str))))
        .get_result(conn)
        .expect("Error checking if user exists")
}

// Pattern 5: Increment counter
fn increment_view_count(conn: &mut PgConnection, post_id: i32) {
    // Assuming posts table has view_count column
    use self::posts::dsl::*;
    
    diesel::update(posts.find(post_id))
        .set(title.eq(title)) // Diesel requires at least one set
        // Use raw SQL for increment: SET view_count = view_count + 1
        .execute(conn)
        .expect("Error incrementing view count");
}
```